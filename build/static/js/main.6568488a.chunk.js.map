{"version":3,"sources":["state/badge/reducer.tsx","state/badge/context.tsx","component/badgeImg.tsx","constant/api-path.tsx","config/index.ts","api/api-client.tsx","api/badge-service.tsx","state/pagequery/page.tsx","component/badgeInfiniteList.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["BadgesInitialState","badges","BadgeContext","React","createContext","useBadgeContext","useContext","BadgeListProvider","children","useState","badgesState","Provider","value","BadgeImg","require","badge","localStorage","getItem","webScraperOrder","dataImage","imageSrc","badgeSrc","useEffect","wrapperStyle","minHeight","onLoad","e","loading","alt","gameHref","src","APIEndPoints","process","API","validateStatus","status","authorizedHttpClient","axiosInstance","this","axios","create","baseURL","EnvConfig","apiBaseUrl","headers","Accept","timeout","path","params","get","result","console","log","HttpClient","handleResponse","translateAxiosError","payload","config","post","delete","put","patch","response","data","code","Error","message","page","index","size","count","Promise","resolve","initialPageParam","useQueryPagingStatus","pageIndex","setPageIndex","pageSize","setPageSize","pageCount","setPageCount","badgeListStyle","maxWidth","margin","BadgeInfiniteList","badgeContext","isLoading","setIsLoading","hasMore","setHasMore","setBadges","items","setItems","onLoadMore","length","loadAllBadges","map","i","span","loadingBadges","pop","push","a","BadgeService","getBadgePaged","then","badgeRes","maxPages","rows","align","justify","pageStart","loadMore","loader","className","grid","gutter","xxl","style","bordered","dataSource","renderItem","item","Item","href","target","text","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"wPAGO,IAAMA,EAAiC,CAC1CC,OAAQ,ICAZ,IAAMC,EAAeC,IAAMC,cAA0BJ,GAC/CK,EAAkB,kBAAkBC,qBAAWJ,IAUxCK,EAAoB,SAAC,GAI3B,IAHHC,EAGE,EAHFA,SAGE,EAC+BC,mBAAST,GADxC,mBACKU,EADL,UAIF,OACI,cAACR,EAAaS,SAAd,CAAuBC,MAAOF,EAA9B,SACKF,K,4DC2DEK,GAhFOC,EAAQ,KAMY,SAAC,GAAe,IAAbC,EAAY,EAAZA,MAAY,EAEnBN,mBAASO,aAAaC,QAAQF,EAAMG,kBAFjB,mBAE9CC,EAF8C,aAIrBV,mBAASU,GAAwBJ,EAAMK,WAJlB,mBAI9CC,EAJ8C,UAMrDC,qBAAU,cAGP,IAsDH,OACI,cAAC,IAAD,CACIC,aAAc,CAAEC,UAAY,IAC5BC,OAvDS,SAACC,GACd,OAAOX,EAAMK,UAuDTO,QAAQ,OACRC,IAAKb,EAAMc,SACXC,IAAKT,M,kCC/EJU,EACF,S,kBCUI,G,OAAA,I,mGAJP,OAAQC,mIAAYC,KALhB,gD,OCQCC,EAAiB,SAACC,GAC7B,OAAOA,GAAU,KAAOA,EAAS,KA6FtBC,EAAuB,IAlFpC,WAGE,aAAe,yBAFLC,mBAEI,EACZC,KAAKD,cAAgBE,IAAMC,OAAO,CAChCC,QAASC,EAAUC,WACnBC,QAAS,CACPC,OAAQ,mBACR,eAAgB,oBAElBX,iBACAY,QAAS,MAXf,yFAmBsBC,EAAcC,GAnBpC,gGAqB2BV,KAAKD,cAAcY,IAAOF,EAAM,CAAEC,WArB7D,cAqBYE,EArBZ,OAsBMC,QAAQC,IAAIL,GAtBlB,kBAuBaM,EAAWC,eAAeJ,IAvBvC,sCAyBYG,EAAWE,oBAAX,MAzBZ,sLA8B0BR,EAAcS,EAAYC,GA9BpD,gGAgC2BnB,KAAKD,cAAcqB,KAAQX,EAAMS,EAASC,GAhCrE,cAgCYP,EAhCZ,yBAiCaG,EAAWC,eAAeJ,IAjCvC,sCAmCYG,EAAWE,oBAAX,MAnCZ,0LAuCsBR,GAvCtB,0FAyCYT,KAAKD,cAAcsB,OAAaZ,GAzC5C,4DA2CYM,EAAWE,oBAAX,MA3CZ,kLAgDyBR,EAAcS,EAAYC,GAhDnD,gGAkD2BnB,KAAKD,cAAcuB,IAAOb,EAAMS,EAASC,GAlDpE,cAkDYP,EAlDZ,yBAmDaG,EAAWC,eAAeJ,IAnDvC,sCAqDYG,EAAWE,oBAAX,MArDZ,yLAyD2BR,EAAcS,GAzDzC,gGA2D2BlB,KAAKD,cAAcwB,MAASd,EAAMS,GA3D7D,cA2DYN,EA3DZ,yBA4DaG,EAAWC,eAAeJ,IA5DvC,sCA8DYG,EAAWE,oBAAX,MA9DZ,8IAgBI,OAAOjB,KAAKD,iBAhBhB,sCAkEmCyB,GAC/B,MAAO,CAAEC,KAAMD,EAASC,QAnE5B,0CAsEqCrC,GAAuB,IAChDoC,EAAapC,EAAboC,SACR,MAAe,iBAAXpC,EAAEsC,KACG,IAAIC,MAAMvC,EAAEwC,SAEL,MAAZJ,EACK,IAAIG,MAAMH,EAASC,MAErB,IAAIE,MAAM,yEA9ErB,MC2Ce,M,mOA9CgB7B,EAAqBa,IACxClB,G,UADE+B,E,OAGNX,QAAQC,IAAIU,IACTA,IAAYA,EAASC,K,yCACbD,EAASC,M,aAEd,IAAIE,MAAM,mC,8KAGOE,G,uFACA/B,EAAqBa,IAArB,UACflB,EADe,sBACkBoC,EAAKC,MADvB,qBACyCD,EAAKE,KAD9C,sBACgEF,EAAKG,Q,UADtFR,E,OAGNX,QAAQC,IAAIU,IACTA,IAAYA,EAASC,K,yCACbD,EAASC,M,aAEd,IAAIE,MAAM,mC,6KAGKlD,G,8EACrBoC,QAAQC,IAAIrC,G,SACWqB,EAAqBsB,KACxC3B,EAAoB,CAAEhB,U,UADpB+C,E,OAGNX,QAAQC,IAAIU,IACTA,E,yCACQS,QAAQC,W,aAEb,IAAIP,MAAM,mC,8KAGMhE,G,8EACtBkD,QAAQC,IAAInD,G,SACWmC,EAAqBsB,KACxC3B,EAAoB,CAAE9B,UAAU,CAAE6C,QAAS,M,UADzCgB,E,OAGNX,QAAQC,IAAIU,IACTA,E,yCACQS,QAAQC,W,aAEb,IAAIP,MAAM,mC,0GCrDlBQ,EAAmB,CACrBL,MAAO,EACPC,KAAM,IACNC,MAAO,GAWII,EARc,WAA8B,IAA7BP,EAA4B,uDAArBM,EAAqB,EACpBhE,mBAAS0D,EAAKC,OADM,mBAC/CO,EAD+C,KACpCC,EADoC,OAEtBnE,mBAAS0D,EAAKE,MAFQ,mBAE/CQ,EAF+C,KAErCC,EAFqC,OAGpBrE,mBAAS0D,EAAKG,OAHM,mBAG/CS,EAH+C,KAGpCC,EAHoC,KAKxD,MAAO,CAAEL,YAAWE,WAAUE,YAAWH,eAAcE,cAAaE,iBCJhEC,EAAiC,CACnCC,SAAU,OACVC,OAAQ,QAGNV,EAAmB,CACrBL,MAAO,EACPC,KAAM,IACNC,MAAO,GA4KIc,EAzKqB,WAChC,IAAMC,EAAehF,IADiB,EAEJI,oBAAS,GAFL,mBAE/B6E,EAF+B,KAEpBC,EAFoB,OAG8Cb,EAAqBD,GAAjGE,EAH8B,EAG9BA,UAAWE,EAHmB,EAGnBA,SAAUE,EAHS,EAGTA,UAAWH,EAHF,EAGEA,aAA2BI,GAH7B,EAGgBF,YAHhB,EAG6BE,cAH7B,EAORvE,oBAAS,GAPD,mBAO/B+E,EAP+B,KAOtBC,EAPsB,OAQVhF,mBAFA,IANU,mBAQ/BR,EAR+B,KAQvByF,EARuB,OAaZjF,mBAAgB,IAbJ,mBAa/BkF,EAb+B,KAaxBC,EAbwB,KAetCtE,qBAAU,WAEHgE,GAAaE,GAAWb,EAAY,GACvCkB,MACD,IAEHvE,qBAAU,WACF+D,EAAapF,QAAUoF,EAAapF,OAAO6F,OAAS,GAAGL,GAAW,GACtEM,MACD,CAACV,IAEJ/D,qBAAU,WACNrB,EAAO+F,KAAI,SAACjF,EAAOkF,GAEfL,EAAS,GAAD,mBAAKD,GAAL,CAAY,cAAC,IAAD,CAAKO,KAAM,IAAX,SAAgB,cAAC,EAAD,CAAUnF,MAAQA,cAE3D,CAACd,IAGJ,IAAM8F,EAAgB,WAElB,IADA,IAAMI,EAA0B,GACvBF,EAAI,EAAGA,EAAIZ,EAAapF,OAAO6F,OAAQG,IAAK,CACjD,IAAMlF,EAAQsE,EAAapF,OAAOmG,MAC5BrF,GACFoF,EAAcE,KAAKtF,GAGvBoF,EAAcL,QAAQJ,EAAU,GAAD,mBAAKzF,GAAWkG,IACnDnB,EAAaD,EAAY,IAqCvBc,EAAU,uCAAG,4BAAAS,EAAA,0DACZhB,EADY,wDAEfC,GAAa,GACPpB,EAAkB,CACpBG,MAAOS,EACPX,MAAOO,EACPN,KAAMQ,GANK,SAQT0B,EAAaC,cAAcrC,GAC5BsC,MAAK,SAACC,GACH,GAAGA,EAAU,CAAC,IACFC,EAAmBD,EAAnBC,SAAUC,EAASF,EAATE,KACdA,EAAKd,SACLL,GAAW,GACXC,EAAU,GAAD,mBAAKzF,GAAL,YAAgB2G,KACzBhC,EAAaD,EAAY,GACzBY,GAAa,IAEdoB,GAAYhC,GACXc,GAAW,OAnBZ,2CAAH,qDAqDhB,OACI,cAAC,IAAD,CAAKoB,MAAM,SAASC,QAAQ,SAA5B,SACI,cAAC,IAAD,UACI,cAAC,IAAD,UACI,cAAC,IAAD,CACIC,UAAW,EACXC,SAAUnB,EACVL,QAASA,EACTyB,OAAQ,qBAAKC,UAAU,SAAf,wBAA6B,GAJzC,SAMI,cAAC,IAAD,CACIC,KAAM,CACFC,OAAQ,EACRC,IAAK,GAETC,MAAOrC,EACPsC,UAAU,EACVC,WAAYvH,EACZwH,WAAY,SAAAC,GAAI,OAChB,eAAC,IAAKC,KAAN,WACI,uBACA,uBACA,cAAC,EAAD,CAAU5G,MAAO2G,IACjB,uBACA,mBAAGE,KAAMF,EAAK7F,SAAUgG,OAAO,SAA/B,SAAyCH,EAAKI,SALlCJ,EAAKxG,6BC/JlC6G,EAZO,WACpB,OACE,cAAC,EAAD,UACE,qBAAKb,UAAU,MAAf,SACE,8BACE,cAAC,EAAD,WCEKc,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBzB,MAAK,YAAkD,IAA/C0B,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCFdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.6568488a.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { BadgeAction, BadgeActionTypes, BadgeState } from \"./action\"\r\n\r\nexport const BadgesInitialState: BadgeState = {\r\n    badges: [\r\n    ],\r\n}\r\n\r\nexport function BadgeReducer(state: BadgeState, action: BadgeAction): BadgeState {\r\n    switch (action.type) {\r\n        case BadgeActionTypes.ADD_BADGE:\r\n            console.log(\"janana\", state);\r\n            return { badges: [...state.badges, { ...action.badge }] };\r\n        case BadgeActionTypes.REMOVE_BADGE:\r\n            return { badges: [...state.badges, { ...action.badge }] };\r\n        default:\r\n            return { badges: [...state.badges] };\r\n    }\r\n}","import React, { useContext, useState } from \"react\";\r\nimport { BadgeState } from \"./action\";\r\nimport { BadgesInitialState } from \"./reducer\";\r\n\r\nconst BadgeContext = React.createContext<BadgeState>(BadgesInitialState);\r\nconst useBadgeContext = ():BadgeState  => useContext(BadgeContext);\r\n\r\nexport const useBadgeListState = (): BadgeState => {\r\n    const context = React.useContext(BadgeContext);\r\n    if (undefined === context) {\r\n        throw new Error(\"Please use within BadgeListStateProvider\");\r\n    }\r\n    return context;\r\n};\r\n\r\nexport const BadgeListProvider = ({\r\n    children\r\n}: {\r\n    children: React.ReactNode;\r\n}) => {\r\n    const [badgesState, setBadges] = useState(BadgesInitialState);\r\n\r\n    // useeffect get badgesstate \r\n    return (\r\n        <BadgeContext.Provider value={badgesState}>\r\n            {children}\r\n        </BadgeContext.Provider>\r\n    );\r\n};\r\n\r\nexport default BadgeContext;\r\nexport { useBadgeContext }\r\n","import React, { useEffect, useReducer, useState } from 'react';\r\nimport { IBadge } from '../model/badge';\r\nimport { Image } from 'antd';\r\n\r\nconst imageToBase64 = require('image-to-base64');\r\n\r\ntype BadgeImgProps = {\r\n    badge: IBadge;\r\n}\r\n\r\nconst BadgeImg: React.FC<BadgeImgProps> = ({ badge }) => {\r\n    // start local data as locall data\r\n    const [dataImage, setDataImage] = useState(localStorage.getItem(badge.webScraperOrder));\r\n    // start badge as preview\r\n    const [badgeSrc, setBadgeSrc] = useState(dataImage ? dataImage : badge.imageSrc);\r\n\r\n    useEffect(() => {\r\n        // if local data is empty, call requets\r\n        //if (!dataImage) saveImgURL();\r\n    }, []);\r\n    \r\n    const onLoaded = (e: any) => {\r\n        return badge.imageSrc\r\n    }\r\n\r\n    //call request \r\n    const toDataURL = (url: string, callback: any) => {\r\n        const xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url);\r\n        xhr.setRequestHeader(\"Access-Control-Allow-Origin\", \"*\");\r\n        xhr.onload = function () {\r\n            const reader = new FileReader();\r\n            reader.onloadend = function () {\r\n                callback(reader.result);\r\n            }\r\n            reader.readAsDataURL(xhr.response);\r\n        };\r\n        xhr.responseType = 'blob';\r\n        xhr.send();\r\n    }\r\n\r\n    // call request to download image and store\r\n    const saveImgURL = () => {\r\n        \r\n        //console.log(\"saving to cookie!\", badge.imageSrc);\r\n        imageToBase64(badge.imageSrc) // Image URL\r\n            .then(\r\n                (response: string) => {\r\n                    storeImgURL(\"data:image/png;base64,\"+response);\r\n                    setBadgeSrc(\"data:image/png;base64,\"+response);\r\n                }\r\n            )\r\n            .catch(\r\n                (error: any) => {\r\n                    //console.log(error); // Logs an error if there was one\r\n                }\r\n            )\r\n\r\n\r\n        // toDataURL(badge.imageSrc, (dataUrl: any) => {\r\n        //     console.log('RESULT:', dataUrl)\r\n\r\n        //     storeImgURL(dataUrl);\r\n        //     setBadgeSrc(dataUrl)\r\n        // });\r\n    }\r\n\r\n    // when downloaded\r\n    const storeImgURL = (dataUrl: string) => {\r\n        localStorage.setItem(badge.webScraperOrder, dataUrl)\r\n    }\r\n\r\n\r\n    return (\r\n        <Image\r\n            wrapperStyle={{ minHeight : 80 }}\r\n            onLoad={onLoaded}\r\n            loading=\"lazy\"\r\n            alt={badge.gameHref}\r\n            src={badgeSrc}\r\n        />\r\n    );\r\n}\r\n\r\nexport default BadgeImg;\r\n","export const APIEndPoints = {\r\n    badge: \"/badge\",\r\n    badges: \"/badges\"\r\n}","import { get } from \"lodash\";\r\n\r\nconst api = \"https://secret-narrow-water.glitch.me/api\";\r\nconst api2 = \"http://localhost:3001/api/v1\";\r\n\r\nclass Config {\r\n    public get apiBaseUrl(): string {\r\n        return  process.env.API || api || get(window, \"_env.API_BASE_URL\", \"\");\r\n    }\r\n}\r\n\r\nexport default new Config();\r\n","// eslint-disable-next-line max-classes-per-file\r\nimport axios, { AxiosError, AxiosInstance, AxiosResponse, AxiosRequestConfig } from \"axios\";\r\nimport { StatusCodes } from \"http-status-codes\";\r\nimport _ from \"lodash\";\r\nimport EnvConfig from \"../config\";\r\n\r\nexport type ApiService<P, R> = (payload?: P) => Promise<ApiResponse<R>>;\r\n\r\nexport const headersForBulkOperation = { \"pph-action\": \"bulk\" };\r\n\r\nexport const validateStatus = (status: number): boolean => {\r\n  return status >= 200 && status < 300;\r\n};\r\n\r\nexport interface ApiResponse<T> {\r\n  data?: T;\r\n}\r\n\r\nexport type RequestParam = {\r\n  [key: string]: any;\r\n};\r\n\r\nexport class HttpClient {\r\n  protected axiosInstance: AxiosInstance;\r\n\r\n  constructor() {\r\n    this.axiosInstance = axios.create({\r\n      baseURL: EnvConfig.apiBaseUrl,\r\n      headers: {\r\n        Accept: \"application/json\",\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      validateStatus,\r\n      timeout: 20000\r\n    });\r\n  }\r\n\r\n  public get axios(): AxiosInstance {\r\n    return this.axiosInstance;\r\n  }\r\n\r\n  public async get<T>(path: string, params?: RequestParam): Promise<ApiResponse<T>> {\r\n    try {\r\n      const result = await this.axiosInstance.get<T>(path, { params });\r\n      console.log(path);\r\n      return HttpClient.handleResponse(result);\r\n    } catch (e) {\r\n      throw HttpClient.translateAxiosError(e);\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line no-shadow\r\n  public async post<T, P>(path: string, payload: P, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\r\n    try {\r\n      const result = await this.axiosInstance.post<P>(path, payload, config);\r\n      return HttpClient.handleResponse(result);\r\n    } catch (e) {\r\n      throw HttpClient.translateAxiosError(e);\r\n    }\r\n  }\r\n\r\n  public async delete(path: string): Promise<void> {\r\n    try {\r\n      await this.axiosInstance.delete<void>(path);\r\n    } catch (e) {\r\n      throw HttpClient.translateAxiosError(e);\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line no-shadow\r\n  public async put<T, P>(path: string, payload: P, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {\r\n    try {\r\n      const result = await this.axiosInstance.put<T>(path, payload, config);\r\n      return HttpClient.handleResponse(result);\r\n    } catch (e) {\r\n      throw HttpClient.translateAxiosError(e);\r\n    }\r\n  }\r\n\r\n  public async patch<T, P>(path: string, payload: P): Promise<ApiResponse<T>> {\r\n    try {\r\n      const result = await this.axiosInstance.patch<T>(path, payload);\r\n      return HttpClient.handleResponse(result);\r\n    } catch (e) {\r\n      throw HttpClient.translateAxiosError(e);\r\n    }\r\n  }\r\n\r\n  private static handleResponse<T>(response: AxiosResponse): ApiResponse<T> {\r\n    return { data: response.data as T };\r\n  }\r\n\r\n  private static translateAxiosError(e: AxiosError): Error {\r\n    const { response } = e;\r\n    if (e.code === \"ECONNABORTED\") {\r\n      return new Error(e.message);\r\n    }\r\n    if (response != null) {\r\n      return new Error(response.data);\r\n    }\r\n    return new Error(\"Unable to contact the server at this time. Please try again later\");\r\n  }\r\n}\r\n\r\nexport const authorizedHttpClient = new HttpClient();","import { APIEndPoints } from \"../constant/api-path\";\r\nimport { IBadge } from \"../model/badge\";\r\nimport { PageParam } from \"../state/pagequery/page\";\r\nimport { authorizedHttpClient } from \"./api-client\";\r\n\r\ntype GetBadgeResponse = {\r\n    count: number,\r\n    maxPages: number,\r\n    rows: IBadge[],\r\n}\r\ntype CreateBadgePayload = {\r\n    badge: IBadge\r\n}\r\ntype CreateBadgesPayload = {\r\n    badges: IBadge[]\r\n}\r\n\r\nclass BadgeService {\r\n    public async getBadge(): Promise<GetBadgeResponse> {\r\n        const response = await authorizedHttpClient.get<GetBadgeResponse>(\r\n            APIEndPoints.badge\r\n        )\r\n        console.log(response);\r\n        if(response && response.data) {\r\n            return response.data;\r\n        }\r\n        throw new Error(\"Get Badge service returns null.\");\r\n    }\r\n\r\n    public async getBadgePaged(page: PageParam): Promise<GetBadgeResponse> {\r\n        const response = await authorizedHttpClient.get<GetBadgeResponse>(\r\n            `${ APIEndPoints.badge }?pageIndex=${page.index}&pageSize=${page.size}&pageCount=${page.count}`\r\n        )\r\n        console.log(response);\r\n        if(response && response.data) {\r\n            return response.data;\r\n        }\r\n        throw new Error(\"Get Badge service returns null.\");\r\n    }\r\n    \r\n    public async createBadge(badge: IBadge): Promise<void> {\r\n        console.log(badge);\r\n        const response = await authorizedHttpClient.post<void, CreateBadgePayload>(\r\n            APIEndPoints.badge, { badge }\r\n        )\r\n        console.log(response);\r\n        if(response) {\r\n            return Promise.resolve();\r\n        }\r\n        throw new Error(\"Get Badge service returns null.\");\r\n    }\r\n    \r\n    public async createBadges(badges: IBadge[]): Promise<void> {\r\n        console.log(badges);\r\n        const response = await authorizedHttpClient.post<void, CreateBadgesPayload>(\r\n            APIEndPoints.badge, { badges }, { timeout: 100000 }\r\n        )\r\n        console.log(response);\r\n        if(response) {\r\n            return Promise.resolve();\r\n        }\r\n        throw new Error(\"Get Badge service returns null.\");\r\n    }\r\n}\r\n\r\nexport default new BadgeService();\r\n","import { useState, useEffect } from 'react';\r\n\r\nexport interface PageParam {\r\n    index: number,\r\n    size: number,\r\n    count: number,\r\n}\r\n\r\nconst initialPageParam = {\r\n    index: 0,\r\n    size: 100,\r\n    count: 0,\r\n}\r\n\r\nconst useQueryPagingStatus = (page = initialPageParam) => {\r\n    const [pageIndex, setPageIndex] = useState(page.index);\r\n    const [pageSize, setPageSize] = useState(page.size);\r\n    const [pageCount, setPageCount] = useState(page.count);\r\n\r\n  return { pageIndex, pageSize, pageCount, setPageIndex, setPageSize, setPageCount };\r\n}\r\n\r\nexport default useQueryPagingStatus;","import React, { useEffect, useState } from 'react';\r\nimport { IBadge } from '../model/badge';\r\nimport { Button, Col, List, Row } from 'antd';\r\nimport { useBadgeContext } from '../state/badge/context';\r\nimport CSVLoader from './csvloader';\r\nimport BadgeImg from './badgeImg';\r\nimport BadgeCanvas from './badgeCanvas';\r\nimport InfiniteScroll from 'react-infinite-scroller';\r\nimport * as CSS from 'csstype';\r\nimport BadgeService from '../api/badge-service';\r\nimport useQueryPagingStatus, { PageParam } from '../state/pagequery/page';\r\nimport { BadgeActionTypes, simulateHttpRequest } from '../state/badge/action';\r\nimport { Badge } from '../dto/badge-dto';\r\n\r\n\r\nconst badgeListStyle: CSS.Properties = {\r\n    maxWidth: \"60em\",\r\n    margin: \"auto\",\r\n};\r\n\r\nconst initialPageParam = {\r\n    index: 0,\r\n    size: 100,\r\n    count: 0,\r\n}\r\n\r\nconst BadgeInfiniteList: React.FC = () => {\r\n    const badgeContext = useBadgeContext();\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const { pageIndex, pageSize, pageCount, setPageIndex, setPageSize, setPageCount } = useQueryPagingStatus(initialPageParam);\r\n    \r\n\r\n    const allBadges: IBadge[] = [];\r\n    const [hasMore, setHasMore] = useState(false);\r\n    const [badges, setBadges] = useState(allBadges);\r\n\r\n    const onLoadClick = () => {\r\n        loadMoreBadges();\r\n    }\r\n    const [items, setItems] = useState<any[]>([]);\r\n    \r\n    useEffect(() => {\r\n        // load badge context\r\n        if(isLoading || hasMore || pageIndex > 0) return;\r\n        onLoadMore();\r\n    }, []);\r\n    \r\n    useEffect(() => {\r\n        if (badgeContext.badges && badgeContext.badges.length > 0) setHasMore(false);\r\n        loadAllBadges();\r\n    }, [badgeContext]);\r\n\r\n    useEffect(() => {\r\n        badges.map((badge, i) => {\r\n            //console.log(\"badge: \", badge);\r\n            setItems([...items, <Col span={4.5}><BadgeImg badge={ badge }/></Col>]);\r\n        })        \r\n    }, [badges]);\r\n\r\n\r\n    const loadAllBadges = () => {\r\n        const loadingBadges: IBadge[] = [];\r\n        for (let i = 0; i < badgeContext.badges.length; i++) {\r\n            const badge = badgeContext.badges.pop();\r\n            if (!!badge) {\r\n                loadingBadges.push(badge);\r\n            }\r\n        };        \r\n        if (loadingBadges.length) setBadges([...badges, ...loadingBadges]);\r\n        setPageCount(pageCount + 1);\r\n    }\r\n\r\n    const loadMoreBadges = (amount = 1000) => {\r\n        const loadingBadges: IBadge[] = [];\r\n        for (let i = 0; i < amount; i++) {\r\n            const badge = badgeContext.badges.pop();\r\n            if (badge) {\r\n                loadingBadges.push(badge);\r\n            }\r\n        };\r\n        if (loadingBadges.length) setBadges([...badges, ...loadingBadges]);\r\n        //BadgeRepo.bulkCreateBadge(loadingBadges);\r\n    }\r\n\r\n    const loadBadge = async () => {\r\n        const badge = await BadgeService.getBadge();\r\n    } \r\n\r\n    const createBadge = async (badge: IBadge) => {\r\n        await BadgeService.createBadge(badge);\r\n    }       \r\n\r\n    const createBadges = async (badges: IBadge[]) => {\r\n        await BadgeService.createBadges(badges);\r\n    }       \r\n\r\n    const onLoadMoretest = (pageIndex: number) => {\r\n        loadBadgesPagedDB(pageIndex);\r\n        if(isLoading) {\r\n            return;\r\n        }\r\n        if(!hasMore) {\r\n            setIsLoading(false);\r\n        }\r\n    } \r\n\r\n    const onLoadMore = async () => {\r\n        if(isLoading) return;\r\n        setIsLoading(true);\r\n        const page: PageParam = {\r\n            count: pageCount,\r\n            index: pageIndex,\r\n            size: pageSize\r\n        }\r\n        await BadgeService.getBadgePaged(page)\r\n            .then((badgeRes) => {\r\n                if(badgeRes) {\r\n                    const { maxPages, rows } = badgeRes;\r\n                    if (rows.length) {\r\n                        setHasMore(true);\r\n                        setBadges([...badges, ...rows]);\r\n                        setPageIndex(pageIndex + 1);\r\n                        setIsLoading(false);\r\n                    }\r\n                    if(maxPages <= pageIndex) {\r\n                        setHasMore(false);\r\n                    }\r\n                }\r\n            }\r\n        );\r\n    } \r\n\r\n    const startPull = async () => {\r\n        await loadBadgesPagedDB();\r\n    } \r\n\r\n    const loadBadgesPagedDB = async (pageI = 0) => {\r\n        if (isLoading || hasMore) return;\r\n        const page: PageParam = {\r\n            count: pageCount,\r\n            index: pageI,\r\n            size: pageSize\r\n        }\r\n        const data = await BadgeService.getBadgePaged(page);\r\n        if (data.rows.length) setBadges([...badges, ...data.rows]);\r\n        badgeContext.badges.push(...data.rows);\r\n        // data.forEach((badge) => {        \r\n        //     setHasMore(true);\r\n        //     badgeContext.badges.push(badge);\r\n        //     simulateHttpRequest( {\r\n        //         type: BadgeActionTypes.ADD_BADGE,\r\n        //         badge\r\n        //       });\r\n        // })\r\n        setPageIndex(pageIndex + 1);\r\n        setHasMore(true);\r\n    }\r\n\r\n    //<CSVLoader createBadges={createBadges}/> \r\n    return (\r\n        <Row align=\"bottom\" justify=\"center\">\r\n            <Col>\r\n                <Row>\r\n                    <InfiniteScroll\r\n                        pageStart={0}\r\n                        loadMore={onLoadMore}\r\n                        hasMore={hasMore}\r\n                        loader={<div className=\"loader\" key={0}>Loading ...</div>}\r\n                    >\r\n                        <List\r\n                            grid={{\r\n                                gutter: 0,\r\n                                xxl: 6,\r\n                            }}\r\n                            style={badgeListStyle}\r\n                            bordered={true}\r\n                            dataSource={badges}\r\n                            renderItem={item => (\r\n                            <List.Item key={item.webScraperOrder}>\r\n                                <br />\r\n                                <br />\r\n                                <BadgeImg badge={item} />\r\n                                <br />\r\n                                <a href={item.gameHref} target=\"_blank\">{item.text}</a>\r\n                            </List.Item>\r\n                        )}\r\n                        >\r\n                        </List>\r\n                    </InfiniteScroll>\r\n                </Row>\r\n            </Col>\r\n        </Row>\r\n    );\r\n}\r\n\r\nexport default BadgeInfiniteList;\r\n","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport BadgeList from './component/badgeList';\nimport { BadgeListProvider } from './state/badge/context';\nimport BadgeInfiniteList from './component/badgeInfiniteList';\n\nconst App: React.FC = () => {\n  return (\n    <BadgeListProvider>\n      <div className=\"App\">\n        <div>\n          <BadgeInfiniteList></BadgeInfiniteList>\n        </div>\n      </div>\n    </BadgeListProvider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'antd/dist/antd.css';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}